
# Software Architecture

As mentioned previously, the ADC software developed for the original ExoCube was not rigorously tested and was not designed to be reused on future PolySat missions. This work set out to architect the ADC software in such a way that it was easy to reuse and extend on future missions, compatible with the larger PolySat code base, and testable in the most flight-like configuration possible. Although the control algorithm for ExoCube 2 is beyond the scope of this paper, its place in the software architecture is discussed for the sake of completeness.

Although high-level languages and environments like MATLAB, Simulink, and Python provide robust ecosystems for developing and validating ADC algorithms, PolySat spacecraft are barred from flying these tools due to the highly resource constrained PolySat flight computer. For this reason, the ADC software was written in C to minimize memory footprint and maximize computational efficiency. This choice had the added benefit of being compatible with the wider PolySat code base [@greg].

## Reusability and Extensibility

Reusability and extensibility were achieved by implementing a basic model of object orientation in C [@ooc]. More specifically, we defined several generic interfaces that together accomplish all the features of the ADC software. A high-level diagram of some these interfaces and their interactions is shown in figure \ref{arch}. Each block represents a different interface. In this UML-style diagram, the arrows do not represent inheritance, but rather reflect the dependency hierarchy within the software. In other words, `ADCS State` stores instances of `Mission Determination` and `Mission Controller`, `Mission Controller` contains multiple `Controller` objects, etc. Because these blocks represent interfaces, different implementations can be easily swapped in and out, enabling ADC developers to reuse past implementations and provide new implementations with little trouble. Note that the software utilizes many more generic interfaces than depicted, but they were left out of the diagram to reduce clutter.

The two branches depicted in the diagram represent the two primary states of the software, determination and then control. The yellow arrows at the bottom represent the flow of data within the software--the attitude estimate created by the determination side is passed to the control side, and the control torques generated by the control side are passed back to the determination side.


![Object model for the ADC software architecture.\label{arch}](paper/img/arch.pdf){ width=60% }
