
# Software Architecture

As mentioned previously, the ADC software developed for the original ExoCube was not rigorously tested and was not designed to be reused on future PolySat missions. This work set out to architect the ADC software in such a way that it was easy to reuse and extend on future missions, compatible with the larger PolySat code base, and testable in the most flight-like configuration possible. Although the control algorithm for ExoCube 2 is beyond the scope of this paper, its place in the software architecture is discussed for the sake of completeness.

Although high-level languages and environments like MATLAB, Simulink, and Python provide robust ecosystems for developing and validating ADC algorithms, PolySat spacecraft are barred from flying these tools due to the highly resource constrained PolySat flight computer. For this reason, the ADC software was written in C to minimize memory footprint and maximize computational efficiency. This choice had the added benefit of being compatible with the wider PolySat code base [@greg].

## Reusability and Extensibility

Reusability and extensibility were achieved by implementing a basic model of object orientation in C [@ooc]. More specifically, we defined several generic interfaces that together accomplish all the features of the ADC software. A high-level diagram of some these interfaces and their interactions is shown in figure \ref{arch}. Each block represents a different interface. In this UML-style diagram, the arrows do not represent inheritance, but rather reflect the dependency hierarchy within the software. In other words, `ADCS State` stores instances of `Mission Determination` and `Mission Controller`, `Mission Controller` contains multiple `Controller` objects, etc. Because these blocks represent interfaces, different implementations can be easily swapped in and out, enabling ADC developers to reuse past implementations and provide new implementations with little trouble. Note that the software utilizes many more generic interfaces than depicted, but they were left out of the diagram to reduce clutter.

The two branches depicted in the diagram represent the two primary components of the software, determination and then control. The yellow arrows at the bottom represent the flow of data within the software--the attitude estimate created by the determination side is passed to the control side, and the control torques generated by the control side are passed back to the determination side to be used in the predict step of the Kalman filter.

![Object model for the ADC software architecture.\label{arch}](paper/img/arch.pdf){ width=60% }

**Explain how often everything is called!!!**

To create a complete picture of the software architecture, all of the interfaces will be described from the bottom of the diagram upward, starting on the control side. The lowest level interface is the `Actuator`. This is a lightweight API on top of the drivers for actuator hardware like magnetorquers and reaction wheels. Users can pass torque or magnetic dipole moment vectors to these objects and expect the appropriate physical action to take place. Note the the `Actuator` interface actually refers to a set of interfaces, as the API to generically control reaction wheels is fundamentally different from that of a magnetorquer.

Next we move to the `Controller` interface, which utilizes the `Actuator` interfaces to control the attitude or angular velocities of the spacecraft. The `Mission Controller` object passes the `Controller` an attitude estimate, relevant sensor readings, other data that could be useful within a control law, and potentially a desired orientation or angular velocity for the spacecraft. The `Controller` object is where the actual control law is implemented, and `Controller` objects should generally implement a single control law. For example, there is an implementation of a `BDOT Controller`, which torques the magnetorquers to slow down the spacecraft's angular velocity. One could also imagine implementing a `Reaction Wheel Controller`, which utilizes reaction wheels and some control law to torque the spacecraft into a desired orientation. The torques and dipole moments generated by the the `Controller` is passed back to the determination branch so that they can be included in the Kalman filter predict step.

The `Mission Controller` is responsible for switching between different `Controller`'s as dictated by the mission requirements. For example, if a spacecraft first needs to detumble using BDOT before starting it's primary control law, the `Mission Controller` would run the `BDOT Controller` until some convergence criteria was met, and then initialize the primary control law. The `Controller`'s themselves are thus agnostic to these mission-specific mode changes.

As notated in the diagram, the `Mission Determination` interface and the `Mission Controller` interface a specific to a particular mission. This enables particular missions to change determination and control modes as needed by their specific requirements. For example, 